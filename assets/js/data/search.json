[ { "title": "How to make Swift Macro available using CocoaPods", "url": "/posts/How-to-make-macro-available-from-CocoaPods/", "categories": "Tech, Swift", "tags": "Tech, Swift, Rust", "date": "2024-03-06 21:00:00 +0800", "snippet": "By the release of Swift 5.9, it provides the feature Swift Macro, which is really useful for the developer to reduce boilerplate code and helping to improve the readability of the code.However, as we know, currently most long running projects are using CocoaPods as their dependency manager, while the Swift Macro support officially relies on SwiftPM. This prevents macros from being directly used in the project code and development pods.So this article is about to introduce how to make Swift Macro available using CocoaPods, for host project and other pods.Key Point - using an executable macro pluginInspired by the information in this discussion and this post, it shows that we can provide an executable binary to the Swift Compiler in Xcode settings: add -load-plugin-executable &amp;lt;path-to-plugin-executable&amp;gt;#&amp;lt;executable-module-name&amp;gt; to OTHER_SWIFT_FLAGS.For example:&#39;OTHER_SWIFT_FLAGS&#39; =&amp;gt; &#39;-load-plugin-executable Resources/Macros/MyMacroPlugin#MyMacroPlugin&#39;,That means we can build a plugin executable and provide it through CocoaPods, update the settings in Pods project and host project before or after the pod install command.Okay, let’s do it.(All the example code can be found in this repo)Create a macro plugin executableWe can easily create a demo macro project using Xcode 15 or command line swift package init --type macro. And then update the Package.swift like this:// swift-tools-version: 5.9// The swift-tools-version declares the minimum version of Swift required to build this package.import PackageDescriptionimport CompilerPluginSupportlet package = Package( name: &quot;SwiftyArchitectureMacros&quot;, platforms: [.macOS(.v10_15), .iOS(.v13), .tvOS(.v13), .watchOS(.v6), .macCatalyst(.v13)], products: [ // Product which is a executable plugin for other project&#39;s compiler to integrate. .executable( name: &quot;SwiftyArchitectureMacros&quot;, targets: [&quot;SwiftyArchitectureMacros&quot;]), ], dependencies: [ // Depend on the Swift 5.9 release of SwiftSyntax .package(url: &quot;https://github.com/apple/swift-syntax.git&quot;, from: &quot;509.0.0&quot;), ], targets: [ .executableTarget( name: &quot;SwiftyArchitectureMacros&quot;, dependencies: [ .product(name: &quot;SwiftSyntaxMacros&quot;, package: &quot;swift-syntax&quot;), .product(name: &quot;SwiftCompilerPlugin&quot;, package: &quot;swift-syntax&quot;) ] ), // A test target used to develop the macro implementation. .testTarget( name: &quot;MacrosTests&quot;, dependencies: [ &quot;SwiftyArchitectureMacros&quot;, .product(name: &quot;SwiftSyntaxMacrosTestSupport&quot;, package: &quot;swift-syntax&quot;), ] ), ])There are some important informations: The target SwiftyArchitectureMacros must be a executable target, normally it’s a .macro target. And the product of the executable should target on the executable SwiftyArchitectureMacros. Second, by several tests, the executable target should contain original macro files, not macro definition files. So it means that the definition of the macro should be contained in the pod we build. By using this swift build -c release command, we can get a SwiftyArchitectureMacros executable file in .build/release/.Create a pod to host the macro plugin executableUsing a prepared macro executableNext, we will create a podspec file to host the executable file and add some configurations.We can create a .podspec now, and in my case it is SwiftyArchitectureMacrosPackage.podspec. The key content is below.s.source_files = &#39;Sources/MacrosDefine/*&#39;s.preserve_paths = &#39;Products/**/*&#39;xcode_config = { &#39;OTHER_SWIFT_FLAGS&#39; =&amp;gt; &amp;lt;&amp;lt;-FLAGS.squish -Xfrontend -load-plugin-executable -Xfrontend $(PODS_ROOT)/SwiftyArchitectureMacrosPackage/Products/SwiftyArchitectureMacros#SwiftyArchitectureMacros FLAGS}s.user_target_xcconfig = xcode_config # &amp;lt;-- add to the `Host project`.s.pod_target_xcconfig = xcode_configKey points: The source_files should contain the macro definition files, which are the files that contains the macro definitions like: @freestanding(expression)public macro stringify&amp;lt;T&amp;gt;(_ value: T) -&amp;gt; (T, String) = #externalMacro(module: &quot;SwiftyArchitectureMacros&quot;, type: &quot;StringifyMacro&quot;) The preserve_paths should contain the executable file, which we build before and move it to a folder, like Products/. The user_target_xcconfig and pod_target_xcconfig should contain the same configurations, which integrate the executable to compiler plugin. The s.user_target_xcconfig is used to modify settings of the host project, while the s.pod_target_xcconfig is used to modify settings of the current pod target.Using a script to build a executableInspired by this post, we can also use a script to build the executable.We can create another .podspec file, which is SwiftyArchitectureMacros.podspec in my case, and the key content is below.s.source_files = &#39;Sources/MacrosDefine/*&#39;s.preserve_paths = &#39;Package.swift&#39;, &#39;Sources/**/*&#39;, &#39;Tests/**/*&#39;product_folder = &quot;${PODS_BUILD_DIR}/Products/SwiftyArchitectureMacros&quot;script = &amp;lt;&amp;lt;-SCRIPT.squishenv -i PATH=&quot;$PATH&quot; &quot;$SHELL&quot; -l -c&quot;swift build -c release --product SwiftyArchitectureMacros--package-path \\\\&quot;$PODS_TARGET_SRCROOT\\\\&quot;--scratch-path \\\\&quot;#{product_folder}\\\\&quot;&quot;SCRIPTs.script_phase = { :name =&amp;gt; &#39;Build SwiftyArchitectureMacros macro plugin&#39;, :script =&amp;gt; script, :input_files =&amp;gt; Dir.glob(&quot;{Package.swift, Sources/**/*}&quot;).map { |path| &quot;$(PODS_TARGET_SRCROOT)/#{path}&quot; }, :output_files =&amp;gt; [&quot;#{product_folder}/release/SwiftyArchitectureMacros&quot;], :execution_position =&amp;gt; :before_compile}Besides the key points introduced above, this section also needs attention to several other key points: The preserve_paths should contain the Package.swift and files that are used to build the executable. And don’t forget to update the build config path to #{product_folder}/release/SwiftyArchitectureMacros#SwiftyArchitectureMacros.The benefit is that we don’t need to prepare the executable file, it will be built by the script when the main project starts building, and it won’t have any compatible issue. However you should know that the script will be executed every time when the project builds, and it may takes a long time when there’s no build cache. So I suggest as a SDK provider, you should provide both options.Integrate to other targetsHost projectIf your main codes are in the host project, you can integrate the macro plugin to the host project by adding the following code to the Podfile.pod &#39;SwiftyArchitectureMacrosPackage&#39;#orpod &#39;SwiftyArchitectureMacros&#39;Because of the OTHER_SWIFT_FLAG setting are already inserted by the podspec file into the host project settings, you don’t need to do anything else.import SwiftyArchitectureMacrosPackagefunc test() { let a = 1 let b = 2 let desc = #stringify(a + b) print(desc)}It works fine~Used by other pods or development podsFirst, add the dependency in the other’s podspec:s.dependency &#39;SwiftyArchitectureMacrosPackage&#39;And then it will be a little tricky, because we can’t directly insert the OTHER_SWIFT_FLAG into other pod target settings because: In another’s podspec, hard code the executable path is not a good idea, because the path may changes when you switching the macro pod between local and remote. If a lot of pods are depending on the macro pod, when macro pod setting changes you must update all the pods’ podspec file which is a big trouble.So we need to do some tricks. We can use pod install’s post_install hook to do this. Add these code to your Podfile, it aims to add the OTHER_SWIFT_FLAG setting to the Pods.xcodeproj, and all the pod targets will inherit from it.post_install do |installer_representation| macro_product_folder = &quot;${PODS_BUILD_DIR}/Products/SwiftyArchitectureMacros&quot; installer_representation.pods_project.build_configurations.each do |config| config.build_settings[&#39;OTHER_SWIFT_FLAGS&#39;] = &quot;$(inherited) -load-plugin-executable #{macro_product_folder}/release/SwiftyArchitectureMacros#SwiftyArchitectureMacros&quot; endendNow try pod install and see if all the pod targets are inheriting correctly from the Pods.xcodeproj. If so, you can use the macros in your codes now." }, { "title": "When we talk about politics", "url": "/posts/Talk-abould-the-politics/", "categories": "View Points", "tags": "View Points", "date": "2021-12-29 20:51:00 +0800", "snippet": "如今国内已经越来越难互相谈论社会、政见话题了，原因不乏就是政治教育缺乏，同时也没有讨论环境。本来有很多想说的，但是经历过一次次冲突之后明白了一个道理，要讨论这些，首先需要判断对方的思维体系是趋同的还是趋异的。人类文明进步到今天，一定趋同是文明进步的趋势。所以跟一个趋异的人去讨论问题，他一定会用一些你们根本上的差异点去反驳你，导致不可调和的矛盾。所以，一定要首先从缓和的话题去分析他是属于哪种人。冲突多了，人就会变得不想发表意见，但希望以后我依然能直言个人感受，批判不合理的事情。另外，对于那些觉得批判都是不好的事情的人来说，真的需要认真思考下自己的观念是不是已经太原始了。" }, { "title": "Why we struggled using native code to build apps", "url": "/posts/Why-we-struggled-using-navite-code-to-build-apps/", "categories": "View Points", "tags": "View Points", "date": "2021-11-19 20:02:00 +0800", "snippet": " 以下想法为个人思考，没有讨论对错，没有想去从全局or任意角度为分析，仅为记录。写这篇思考对的思源是，近两天看到朋友圈在发关于腾讯云搭建低代码平台的新闻。文中对低代码的优势总结几个字在于快速、simple、难度低（人人都是工程师😂）。我个人对平台级技术的发展没什么意见，但是我偶尔想到了最近刚在炒的概念 Metaverse (元宇宙)。我感到有点有趣🤔，因为不论以后 Metaverse 想怎么发展（虽然9成目前是来炒作的，但是）如果真的是实现技术，首要的标准是产品体验。更近一步来思考国内外技术的差异点，国内不管是小程序、云平台、低代码等等，他们的用户都是 toB 市场更多，B 市场再实现产品 toC。而国外的优秀产品公司，更注重的是实际对 C 端用户本身的用户体验。这不禁引人思考一个问题，是用户造就了市场，还是市场培养了用户。国内用户（大部分）向来以能忍著称，基本上一个功能重试个几回能成功，那么这个产品就可以用，何况现在平台级的技术体验缺陷也只在于某些设计师、强迫症才能看出来的程度（整段是夸张手法），那么是不是可以说在国内跨平台、高内聚的 toB 产品的生存空间更好呢。透过这个现象我们去看实际的技术本质，其实也很容易发现，国内外的技术趋势也是不同的，移动端技术兴起的时候，优秀的工程师都是追求小而精的技术，再发展跨平台等，而国内则是直接追求大统，其他内容类的则能搬就搬。这两种思路，我个人倾向于前者，因为我的思维框架还是以用户本身会挑选产品为前提进行的，如果一个产品先开始不从体验上精进，则没有意义；国内的思路，看起来就很飘，飘到像是被 KPI 吹起来的一样。然而国内市场的事实却是另外一种思路，因为用户本身对于产品的挑剔并不高，这样厂商的思路就变成了优先抢占用户，使用其他一些手段留住用户，提高壁垒减少流失。从商业竞争上来讲，这种算是正常手段吧，但是作为个人用户，这种竞争我还是想归于非良性竞争。当然作为我个人，我就是属于强迫症中的一员。从小学美术出身，中学看过平面设计，转职 Engineer 之后用过大部分优秀的国外 App，又被 Apple 和各大原生 App 的优秀动效秀了一脸，自此没事看看 dirbbble 什么的，基本口味已经被养刁了。所以作为我的视角，我的用户行为应该是被多元培养的，而国内目前的审美教育还趋于形式化，感觉相比于十几年前都有退步。我很好奇，以后这种环境下培养的用户会不会觉得产品设计其实就是这样，优不优秀也没多大差别？当然这个议题过于大了，审美进步退步也不是我身边的实例能够去举证的。说到这我们就可以说回到主题了，这种大背景大环境下，对于技术本身的影响及未来技术发展的趋势，都会是不一样的。直到现在为止，跨平台技术还是备受市场欢迎的，不论是小程序、ReactNative、Flutter等等，都是这些趋势的产物。反说回来，native coder 的成本过高且给公司带来的对比收益并不大，必然在总体趋势下会落于下风。但是换个环境，比如已经被养刁的某些海外群体用户地区，那么体验对于他们来说可能就是及格分数线。所以公司的技术规划也需要根据目标用户或地区来确定，这种方向上的决定，基本在之后调整的成本是很高的（你看只有 Facebook 没事在技术栈上切来切去）。这个趋势是在以我们以手机为终端的前提下，但是如果 Metaverse 真的发展起来了呢？我们的终端可能就不是手机了，到时候基于手机界面系统建立的体系，就需要洗牌重来。这块的话我就十分看好各大 3D 引擎开发商（赶紧买几股），基于三维框架的搭建会是全新的开发方式，到那时可能平台化和快速搭建平台，就不是现在这么容易的事了。不过这个假设还太早，科技发展近年来并没有这么快，用户体系的跃迁也是日积月累的过程，估计这辈子能看到都不一定呢～再说回我个人，所以我还是更喜欢使用 native code to build apps，并且特别希望添加优秀的动效交互（duang～），这些希望当然都只源于我个人意愿，我心中觉得优秀的 App 应该是什么样，然后偶尔坚持着去实现一己私愿罢了。" }, { "title": "The some in Swift", "url": "/posts/The-some-in-Swift/", "categories": "Tech, Swift", "tags": "Swift", "date": "2021-11-12 15:20:00 +0800", "snippet": " Swift 5 introduced the “Opaque Type” and see how wrong did I think about it.我的思路遇到了什么问题最先开始我以为 some 是一个类似于 ObjC 中 __kindof 的标识，意识到我的错误是在一段时间之后了。说明这个过程和 some 的用法我们需要从我先入为主的乱用开始说起（开始废话了）。我先定义个 Flyable 的协议，然后有 Bird Dragonfly 实现它。protocol Flyable {}class Bird: Flyable {}class Dragonfly: Flyable {}这时候我们有个方法可以随机返回一个可飞行生物：func getSomeFlyableCreatures() -&amp;gt; Flyable { let someRandomCondition = arc4random() % 2 == 1 return someRandomCondition ? Bird() : Dragonfly()}直到现在，所有功能完美运行。然后我们现在尝试在 getSomeFlyableCreatures 返回值类型前加个 some:func getSomeFlyableCreatures() -&amp;gt; some Flyable { let someRandomCondition = arc4random() % 2 == 1 return someRandomCondition ? Bird() : Dragonfly()}然后我们得到一个编译错误： Result values in ‘? :’ expression have mismatching types ‘Bird’ and ‘Dragonfly’意思是返回值表达式中 Bird 和 Dragonfly 类型不匹配。我们只能返回 Bird 或 Dragonfly 其中类型之一。分析so，现在我们需要分析为什么会又这个错误，以及从此分析编译器的逻辑。当返回值不加 some 时，我们的返回值类型时确定的 Protocol 类型 Flyable，所以此时不论是返回 Bird 还是 Dragonfly 编译器通过协议推断都是符合的，所以是可以通过编译的。当我们添加 some 之后为什么不行了呢？通过刚才的结果，我们只能返回其中之一的确定类型，说明编译器在处理 some 时，会自动推断方法内返回的类型，并把它替换到返回类型上。有点点类似范型方法（可以这么理解，但是实际不一样）func getSomeFlyableCreatures&amp;lt;T: Flyable&amp;gt;() -&amp;gt; T所以在添加 some 之后方法体里返回的必须是固定的一种类型。问题更进一步现在我们给 Flyable 加一个定义，定义翅膀材质。class Muscle { }class Cutin { }protocol Flyable { associatedtype wingsMaterial}class Bird: Flyable { typealias wingsMaterial = Muscle}class Dragonfly: Flyable { typealias wingsMaterial = Cutin}然后呢，我们的 getSomeFlyableCreatures 方法就报错了。 Protocol ‘Flyable’ can only be used as a generic constraint because it has Self or associated type requirements这个报错原因大家应该都不陌生，因为方法参数、返回值中的类型必须是确定的类型，在一个 protocol 中包含 associated type 时，其实编译器时无法确定具体类型的。以前我们唯一能做的就是把这个方法改成范型方法，并且放弃使用 Flyable 这个协议类型。但是我们现在可以试着在返回值前面添加 some 来看这个方法行为变成了什么。func getSomeFlyableCreatures() -&amp;gt; some Flyable { return Bird()}在修改方法体返回值为统一的类型后，可以编译通过了～但是实际上这个方法表现等同于func getSomeFlyableCreatures() -&amp;gt; Bird {}与之前我们分析的编译器逻辑相符。Then分析了这么多，其实为之前遇到的 protocol 中的 associated type 问题并没有提供什么帮助。some 更多的还是类似于 SwiftUI 中的 some View，提供了 Opaque Type 的类型推断，方便代码书写和隐藏不关键的类信息，详细可参考这篇提案。[Update Notice] 又被小伙伴提醒了一篇介绍，好像这篇更明确的说明了当初设计的思路。Forum postsFinal关于类型推断，我个人觉得目前 Swift 有个 bug。。protocol Flyable {}class Bird: Flyable {}protocol Builder { associatedtype Result: Flyable func build() -&amp;gt; Result}class NatureBuilder: Builder { func build() -&amp;gt; some Flyable { return Bird() } func bar() -&amp;gt; Result { return Bird() // Error: Cannot convert return expression of type &#39;Bird&#39; to return type &#39;some Flyable&#39; }}按正常语言逻辑来推断的话，在 build() 方法返回 Bird() 的时候就相当于编译器已知道 Builder.Ressult = Bird。但是在其他方法返回值类型为 Result 的方法中，不论返回什么都会报错。当然在上面的例子上我们可以把 bar() 的返回值改成 Bird 以规避问题。在范型类中同样也有这个问题。class NatureBuilder&amp;lt;T: Flyable&amp;gt;: Builder { func build() -&amp;gt; some Flyable { return T() } func bar() -&amp;gt; Result { return T() // Error:... }}我们同样需要把 bar() 的返回值改成 T 才可以，换句话说这种情况下 Builder.Result 只能于内部或相关方法了，不能扩展其他方法。这应该算个 bug 吧lol？" }, { "title": "Compare between RxSwift and ReactiveSwift", "url": "/posts/Compare-between-RxSwift-and-ReactiveSwift/", "categories": "Tech, FRP", "tags": "FRP, Swift, ReactiveSwift, RxSwift", "date": "2021-11-10 18:32:00 +0800", "snippet": "If you asking me which framework should we prefer to use now, my answer is RxSwift🙈. RxSwift 社区更为活跃，并且 RxSwift 实现的是 Rx 通用接口（加上一点点🤏语言特性功能），所以更容易找到文档或查找到相关讨论（包括目前 RxSwift 已经开始开发 concurrency 相关的 feature 了， ReactiveSwift 一点动静都没有。。）。 ReactiveSwift 冷热信号在一些细节上比较难以理解，比如 signal.producer 产生的 producer 和 signal 似乎没什么差别。 RxSwift 的订阅方法返回值 disposable 是不能默认忽略的，所以更强调了生命周期管理。 ReactiveSwift 没有 share、replay 方法，想在订阅的时候拿到之前的值目前我个人会把它从 Signal 换成用 Property，再用 Property.producer 来获取到最近的一个值。一点点奇怪🤏，可能是我没掌握真正的方式😂。 RxSwift 中 flatMap 和 flatMapLatest 定义跟 ReactiveSwift 中的 flatMap(strategy:) 设计角度似乎完全不一样，目前我也没法说哪个设计的更好，不过 ReactiveSwift 中的似乎更好理解和简单。 RxSwift demo 中的 flatMap &amp;amp; flatMapLaest 的例子设计都很复杂，不过看起来更加“响应式”。// ReactSwift re-write RxSwift flatMap demoscopedExample(&quot;signal map signal&quot;) { struct People { let age: MutableProperty&amp;lt;Int&amp;gt; init(age: Int) { self.age = MutableProperty(wrappedValue: age) } } let (people, pInput) = Signal&amp;lt;People, Never&amp;gt;.pipe() let some = People(age: 10) pInput.send(value: some) people.flatMap(.latest) { p in return p.age.producer }.observeValues { age in print(age) } some.age.value = 11 // here won&#39;t print, different from RxSwift. let some2 = People(age: 20) pInput.send(value: some2) some2.age.value = 22}" }, { "title": "Chirpy - Installations and Functions", "url": "/posts/Chirpy-Installations-and-Functions/", "categories": "Blogging, Tutorial", "tags": "typography", "date": "2019-08-08 11:33:00 +0800", "snippet": "Customize the faviconThe favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons.Generate the faviconPrepare a square image (PNG, JPG, or SVG) with a size of 512x512 or more, and then go to the online tool Real Favicon Generator and click the button Select your Favicon image to upload your image file.In the next step, the webpage will show all usage scenarios. You can keep the default options, scroll to the bottom of the page, and click the button Generate your Favicons and HTML code to generate the favicon.Download &amp;amp; ReplaceDownload the generated package, unzip and delete the following two from the extracted files: browserconfig.xml site.webmanifestNow, copy the remaining image files (PNG and ICO) to cover the original files in the folder assets/img/favicons/ of your Jekyll site. If your Jekyll site doesn’t have this directory yet, just create one.The following table will help you understand the changes to the favicon files: File(s) From Online Tool From Chirpy *.PNG ✓ ✗ *.ICO ✓ ✗ browserconfig.xml ✗ ✓ site.webmanifest ✗ ✓ Note: ✓ means keep, ✗ means delete.The next time you build the site, the favicon will be replaced with a customized edition.This post is to show Markdown syntax rendering on Chirpy, you can also use it as an example of writing. Now, let’s start looking at text and typography.Text and TypographyTitlesH1 - headingH2 - headingH3 - headingH4 - headingParagraphI wandered lonely as a cloudThat floats on high o’er vales and hills,When all at once I saw a crowd,A host, of golden daffodils;Beside the lake, beneath the trees,Fluttering and dancing in the breeze.ListsOrdered list Firstly Secondly ThirdlyUnordered list Chapter Section Paragraph Task list TODO Completed Defeat COVID-19 Vaccine production Economic recovery People smile again Description list Sun the star around which the earth orbits Moon the natural satellite of the earth, visible by reflected light from the sunBlock Quote This line to shows the Block Quote.Tables Company Contact Country Alfreds Futterkiste Maria Anders Germany Island Trading Helen Bennett UK Magazzini Alimentari Riuniti Giovanni Rovelli Italy Linkshttp://127.0.0.1:4000FootnoteClick the hook will locate the footnote1, and here is another footnote2.Images Default (with caption)Full screen width and center alignment Shadowshadow effect (visible in light mode) Left aligned Float to left “A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space.” Float to right “A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space.” Mermaid SVG gantt title Adding GANTT diagram functionality to mermaid apple :a, 2017-07-20, 1w banana :crit, b, 2017-07-23, 1d cherry :active, c, after b a, 1dMathematicsThe mathematics powered by MathJax:\\[\\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}\\]When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\]Inline codeThis is an example of Inline Code.Code blockCommonThis is a common code snippet, without syntax highlight and line number.Specific LanguagesConsole$ env |grep SHELLSHELL=/usr/local/bin/bashPYENV_SHELL=bashShellif [ $? -ne 0 ]; then echo &quot;The command was not successful.&quot;; #do the needful / exitfi;Specific filename@import &quot;colors/light-typography&quot;, &quot;colors/dark-typography&quot;Reverse FootnoteEnable Google PVThis post is to enable Page Views on the Chirpy theme based blog that you just built. This requires technical knowledge and it’s recommended to keep the google_analytics.pv.* empty unless you have a good reason. If your website has low traffic, the page views count would discourage you to write more blogs. With that said, let’s start with the setup.Set up Google AnalyticsCreate GA account and propertyFirst, you need to set up your account on Google analytics. While you create your account, you must create your first Property as well. Head to https://analytics.google.com/ and click on Start Measuring Enter your desired Account Name and choose the desired checkboxes Enter your desired Property Name. This is the name of the tracker project that appears on your Google Analytics dashboard Enter the required information About your business Hit Create and accept any license popup to set up your Google Analytics account and create your propertyCreate Data StreamWith your property created, you now need to set up Data Stream to track your blog traffic. After you signup, the prompt should automatically take you to create your first Data Stream. If not, follow these steps: Go to Admin on the left column Select the desired property from the drop-down on the second column Click on Data Streams Add a stream and click on Web Enter your blog’s URLIt should look like this:Now, click on the new data stream and grab the Measurement ID. It should look something like G-V6XXXXXXXX. Copy this to your _config.yml filegoogle_analytics: id: &#39;G-V6XXXXXXX&#39; # fill in your Google Analytics ID # Google Analytics pageviews report settings pv: proxy_endpoint: # fill in the Google Analytics superProxy endpoint of Google App Engine cache_path: # the local PV cache data, friendly to visitors from GFW regionWhen you push these changes to your blog, you should start seeing the traffic on your Google Analytics. Play around with the Google Analytics dashboard to get familiar with the options available as it takes like 5 mins to pick up your changes. You should now be able to monitor your traffic in real time.Setup Page ViewsThere is a detailed tutorial available to set up Google Analytics superProxy. But, if you are interested to just quickly get your Chirpy-based blog display page views, follow along. These steps were tested on a Linux machine. If you are running Windows, you can use the Git bash terminal to run Unix-like commands.Setup Google App Engine Visit https://console.cloud.google.com/appengine Click on Create Application Click on Create Project Enter the name and choose the data center close to you Select Python language and Standard environment Enable billing account. Yeah, you have to link your credit card. But, you won’t be billed unless you exceed your free quota. For a simple blog, the free quota is more than sufficient. Go to your App Engine dashboard on your browser and select API &amp;amp; Services from the left navigation menu Click on Enable APIs and Services button on the top Enable the following APIs: Google Analytics API On the left, Click on OAuth Consent Screen and accept Configure Consent Screen. Select External since your blog is probably hosted for the public. Click on Publish under Publishing Status Click on Credentials on the left and create a new OAuth Client IDs credential. Make sure to add an entry under Authorized redirect URIs that matches: https://&amp;lt;project-id&amp;gt;.&amp;lt;region&amp;gt;.r.appspot.com/admin/auth Note down the Your Client ID and Your Client Secret. You’ll need this in the next section. Download and install the cloud SDK for your platform: https://cloud.google.com/sdk/docs/quickstart Run the following commands: [root@bc96abf71ef8 /]# gcloud init~snip~Go to the following link in your browser: https://accounts.google.com/o/oauth2/auth?response_type=code&amp;amp;client_id=XYZ.apps.googleusercontent.com&amp;amp;redirect_uri=ABCDEFGEnter verification code: &amp;lt;VERIFICATION CODE THAT YOU GET AFTER YOU VISIT AND AUTHENTICATE FROM THE ABOVE LINK&amp;gt;You are logged in as: [blah_blah@gmail.com].Pick cloud project to use:[1] chirpy-test-300716[2] Create a new projectPlease enter numeric choice or text value (must exactly match listitem): 1[root@bc96abf71ef8 /]# gcloud info# Your selected project info should be displayed here Setup Google Analytics superProxy Clone the Google Analytics superProxy project on Github: https://github.com/googleanalytics/google-analytics-super-proxy to your local. Remove the first 2 lines in the src/app.yaml file: - application: your-project-id- version: 1 In src/config.py, add the OAUTH_CLIENT_ID and OAUTH_CLIENT_SECRET that you gathered from your App Engine Dashboard. Enter any random key for XSRF_KEY, your config.py should look similar to this #!/usr/bin/python2.7 __author__ = &#39;pete.frisella@gmail.com (Pete Frisella)&#39; # OAuth 2.0 Client Settings AUTH_CONFIG = { &#39;OAUTH_CLIENT_ID&#39;: &#39;YOUR_CLIENT_ID&#39;, &#39;OAUTH_CLIENT_SECRET&#39;: &#39;YOUR_CLIENT_SECRET&#39;, &#39;OAUTH_REDIRECT_URI&#39;: &#39;%s%s&#39; % ( &#39;https://chirpy-test-XXXXXX.ue.r.appspot.com&#39;, &#39;/admin/auth&#39; ) } # XSRF Settings XSRF_KEY = &#39;OnceUponATimeThereLivedALegend&#39; Tip: You can configure a custom domain instead of https://PROJECT_ID.REGION_ID.r.appspot.com. But, for the sake of keeping it simple, we will be using the Google provided default URL. From inside the src/ directory, deploy the app [root@bc96abf71ef8 src]# gcloud app deploy Services to deploy: descriptor: [/tmp/google-analytics-super-proxy/src/app.yaml] source: [/tmp/google-analytics-super-proxy/src] target project: [chirpy-test-XXXX] target service: [default] target version: [VESRION_NUM] target url: [https://chirpy-test-XXXX.ue.r.appspot.com] Do you want to continue (Y/n)? Y Beginning deployment of service [default]... ╔════════════════════════════════════════════════════════════╗ ╠═ Uploading 1 file to Google Cloud Storage ═╣ ╚════════════════════════════════════════════════════════════╝ File upload done. Updating service [default]...done. Setting traffic split for service [default]...done. Deployed service [default] to [https://chirpy-test-XXXX.ue.r.appspot.com] You can stream logs from the command line by running: $ gcloud app logs tail -s default To view your application in the web browser run: $ gcloud app browse Visit the deployed service. Add a /admin to the end of the URL. Click on Authorize Users and make sure to add yourself as a managed user. If you get any errors, please Google it. The errors are self-explanatory and should be easy to fix.If everything went good, you’ll get this screen:Create Google Analytics QueryHead to https://PROJECT_ID.REGION_ID.r.appspot.com/admin and create a query after verifying the account. GA Core Reporting API query request can be created in Query Explorer.The query parameters are as follows: start-date: fill in the first day of blog posting end-date: fill in today (this is a parameter supported by GA Report, which means that it will always end according to the current query date) metrics: select ga:pageviews dimensions: select ga:pagePathIn order to reduce the returned results and reduce the network bandwidth, we add custom filtering rules 3: filters: fill in ga:pagePath=~^/posts/.*/$;ga:pagePath!@=. Among them, ; means using logical AND to concatenate two rules. If the site.baseurl is specified, change the first filtering rule to ga:pagePath=~^/BASE_URL/posts/.*/$, where BASE_URL is the value of site.baseurl. After Run Query, copy the generated contents of API Query URI at the bottom of the page and fill in the Encoded URI for the query of SuperProxy on GAE.After the query is saved on GAE, a Public Endpoint (public access address) will be generated, and we will get the query result in JSON format when accessing it. Finally, click Enable Endpoint in Public Request Endpoint to make the query effective, and click Start Scheduling in Scheduling to start the scheduled task.Configure Chirpy to Display Page ViewOnce all the hard part is done, it is very easy to enable the Page View on Chirpy theme. Your superProxy dashboard should look something like below and you can grab the required values.Update the _config.yml file of Chirpy project with the values from your dashboard, to look similar to the following:google_analytics: id: &#39;G-V6XXXXXXX&#39; # fill in your Google Analytics ID pv: proxy_endpoint: &#39;https://PROJECT_ID.REGION_ID.r.appspot.com/query?id=&amp;lt;ID FROM SUPER PROXY&amp;gt;&#39; cache_path: # the local PV cache data, friendly to visitors from GFW regionNow, you should see the Page View enabled on your blog.Reference The footnote source &amp;#8617; The 2nd footnote source &amp;#8617; Google Analytics Core Reporting API: Filters &amp;#8617; " }, { "title": "Codable introduced in Swift 4.0", "url": "/posts/Swift-Codable/", "categories": "Tech, Swift", "tags": "Swift, Codable", "date": "2018-06-13 10:55:00 +0800", "snippet": "Swift CodableCodable 其实是组合协议：typealiase Codable = Encodable &amp;amp; DecodableSwift 基础库中的 Codable、JSONEncoder、PropertiesListEncoder 给我们提供了日常所用的基础功能。使用起来也很简单，以 JSONEncoder 为例。struct Cat: Codable { let name: String var age: Int}let sahra = Cat(with: &quot;Sahra&quot;, age: 1)if let result = try? JSONEncoder.encode(aCat) { let stringValue = String.init(data: result, encoding: .utf8) print(stringValue)}// Output:&quot;{&quot;name&quot;:&quot;Sahra&quot;,&quot;age&quot;:1}&quot;专用容器Codable 的默认实现是把当前类型中的变量都默认转换，如果你定义的类型中，要含有一些其他属性，而不希望这些属性自动转换，我们可以定义一个容器来使用。struct CatContainer { let cat: Cat init(with cat: Cat) { self.cat = cat } // Other properties var storedID: String = &quot;&quot;}依实际使用的情况而定，也可以使用泛型的容器。struct Container&amp;lt;T: Codable&amp;gt; { let element: T init(with element: T) { self.element = element }}重定义 CodingKeys我们可以用另外一种方法忽略部分属性或者改变编码或解码对应的 key 值。在结构体或类中定义枚举类型 CodingKeys，将需要编码的属性包含其中。如果需要改变编码后的命名，则用枚举 String raw value 来表示相应属性。普通情况下，用 Int 类型会节省开销。struct Cat: Codable { let name: String var age: Int = 0 // 如果没有初始值，编译器会报错。 enum CodingKeys: String, CodingKey { case name = &quot;pet_name&quot; }}// Output:&quot;{&quot;pet_name&quot;:&quot;Sahra&quot;}&quot;CodingKeys 中的元素名必须与属性名一一对应。除此之外，还可以更进一步自定义编解码动作，比如 nested 型结构的编解码，可以在这篇官方文档中找到更多信息。Tips Optional 类型系统默认对于 Optional 的实现是，如果为 nil 的情况下，不会将该属性编码。如果你的业务方需要在属性为空时，JSON 对象中表示 null的话，需要定义 CodingKeys 并指定含有这个属性即可。 关于 [Hashable: Any] 类型的编解码对于代码迁移的工程来说，有很多部分代码还使用例如 [String: Any] 的字典类型来传递数据。Any 并不符合 Codable 协议，所以是时候使用 [Hashable: Codable] 重构这部分代码了:)问题 没有找到 Codable 的协议默认实现，却可以不用实现协议方法。 CodingKeys 的实现原理，结合编译信息，猜测是编译时期工作。通过代码及注释信息，其实是分辨不出来 CodingKeys 的用法的，需要参考官方文档。个人觉得这是缺点之一，一是觉得实现原理不透明，不太容易理解；二是没有显式说明 Codable 和 CodingKeys 的关系。比如类型中需要编解码的属性其实编译时期都会校验是否都是 Codable 的，这点在编码的时候是体现不出来的。" }, { "title": "Swift Tips (3) - Protocol", "url": "/posts/Swift-Tips-(3)/", "categories": "Tech, Swift", "tags": "Swift", "date": "2018-06-07 15:55:00 +0800", "snippet": "protocol 组合其实 Any 是 protocol&amp;lt;&amp;gt; 的同名写法，可以用来表示任意类型。protocol&amp;lt;&amp;gt; 的标准语法形式是：protocol&amp;lt;ProtocolA, ProtocalB&amp;gt;。protocol 组合是可以使用 typealias 来命名的，这样可以提高我们的代码可读性：typealise ServerType = protocol&amp;lt;URLDestination, DataResolver&amp;gt;可选接口 (optional protocol)一种方法是标记 protocol 为@objc, 则可以使用 Objective-C 中的关键字optional:@objc protocol OptionalProtocol { optional func optionalMethod()}但是缺点是,@objc修饰的 protocol 只能提供给类使用,struct 和 enum 不能继承。我们可以用另一种办法 extension protocol,给 protocol 的方法提供默认实现。protocol OptionalProtocol { func optionalMethod()}extension OptionalProtocol { func optionalMethod() { ... }}Class A: OptionalProtocol { }let a = A()a.optionalMethod()接口扩展之后,类实现接口的默认方法实现,即是扩展里的实现方法。这个写法也有个坏处,其他的使用者可能会不了解接口已经做过扩展,所以协议和扩展尽量写在同一个文件中,并注释清楚。protocol 扩展和方法覆盖protocol 扩展可以为 protocol 类型提供额外的方法实现，就如 optional 实现原理一样。我们也可以在具体类的实现中覆盖这些方法：protocol Progress { func start()}extension Progress { func start() { print(&quot;nothing&quot;) }}class Request: Progress { func start() { print(&quot;request&quot;) }}let req = Request()req.start() // Print:// request那现在再给 Progress 扩展一个定义中不含有的方法：extension Progress { func cancel() { print(&quot;nothing&quot;) }}class Request: Progress { func start() { print(&quot;request&quot;) } func cancel() { print(&quot;cancel&quot;) }}let req = Request()req.cancel() ==&amp;gt; cancel(req as Progress).cancel() ==&amp;gt; nothing可以看到，对于类和接口里都实现了方法，且方法不在接口定义中时，实际调用时根据当前类型判断的，如果是 Request 则调用类中的方法，如果是 Protocol 则调用协议扩展中的方法。Protocol Assosiated Type我们可以在 protocol 中添加一个 associatedtype 类型关联，实现协议的类型需要完成协议中的类型指定。protocol StorableInfo { associatedtype InfoKey}class Request: StorableInfo { typealias InfoKey: String var storedInfo: [InfoKey: Any]}在 Swift 4.0 中引入了 where 条件语句, 这样就可以更加灵活的运用一些泛型类型。protocol StorableInfo { associatedtype InfoKey where InfoKey: Hashable}// 在以前是编译不通过的，因为 M.InfoKey 不一定符合 Hashableclass Request&amp;lt;M: StorableInfo&amp;gt; { var stroedInfo: [M.InfoKey: Any]}Self、.self 和 .Type .self 实际上是返回当前对象，如果是类型就返回当前类的元类型：let user = User()user.self == user // ==&amp;gt; truelet userType = User.self // User.Type Self 一般使用在接口中，用来表明实现接口本身的对象：protocol Producer { static func instance() -&amp;gt; Self}extension User: Producer { static func instance() -&amp;gt; Self { return self.init() }} 这里有个问题，使用 self.init() 返回才能符合 Self，而不能使用 User() ，虽然这里 User 和 Self 等价。原因是在 non-final class 中实现方法，这个类是有可能被继承的，而如果使用 User() 这种写法，显然子类调用之后就不会返回子类的对象了。 .Type 是表明一个类的元类型，现在可以使用type(of:)方法来获得指定实例的元类型：let type: User.Type = User.selflet metaType = type(of: user) ===&amp;gt; User.Type" }, { "title": "Swift Tips (2) - Standards", "url": "/posts/Swift-Tips-(2)/", "categories": "Tech, Swift", "tags": "Swift", "date": "2018-06-07 15:35:00 +0800", "snippet": "方法参数命名规范由于Objective-C API的命名转换，到Swift API的更新，现在（Swift 4.0）我们更应该使用靠近Swift系统的命名方式：func convert(_ point: CGPoint, from view: UIView?) -&amp;gt; CGPoint 不符合规范的：func convertPoint(_ point: CGPoint, fromView view: UIView?) -&amp;gt; CGPoint类的初始化类的初始化方法分为三种，DESIGNATED，CONVENIENCE 和 REQUIRED。对于初始化方法，必须遵循： 初始化路径必须保证对象完全初始化，这可以通过调用本类型的 designated 初始化方法来得到保证； 子类的 designated 初始化方法必须调用父类的 designated 方法，以保证父类也完成初始化。convenience 方法是 Swift 初始化方法中的 “二等公民”，只作为补充和提供使用上的方便。所有的 convenience 初始化方法都必须调用同一个类中的 designated 初始化完成设置，另外 convenience 的初始化方法是不能被子类重写或者是从子类中以 super 的方式被调用的。对于某些我们希望子类中一定实现的 designated 初始化方法，我们可以通过添加 required 关键字进行限制，强制子类对这个方法重写实现。这样做的最大的好处是可以保证依赖于某个 designated 初始化方法的 convenience 一直可以被使用。属性访问控制现在的 Swift 版本（4.1），private关键字的访问权限已经改为：当前模组下的私有属性。Swift 5.x, private 已经修改为当前 class or struct/enum… 且在当前文件下才能访问到的私有属性。// Module: libSomeclass User { private var id: String}extension User { func foo() { print(id) // accessible }}// Other app or lib:@import libSomeextension User { func bar() { print(id) // value of type &#39;User&#39; has no member &#39;id&#39; }}其他关键字还有public、internal、fileprivate，含义为公开、内部、文件私有，默认使用的是internal，严格的使用访问控制，可以优化代码和模组的使用，也会减少许多不必要的麻烦。另外对于 Swift 中的只读属性也是通过访问控制完成的：class User { private(set) var id: String fileprivate(set) var local: String}嵌套 enum在 enum 里编译器是不允许直接嵌套使用的，我们可以添加 indirect 使编译器通过编译。indirect enum Node&amp;lt;Value&amp;gt; { case empty case value(value: Value, left: Node&amp;lt;Value&amp;gt;, right: Node&amp;lt;Value&amp;gt;)}let leaf = Node.value(value: 1, left: .empty, right: .empty)LockObjective-C 中的@synchronized其实是使用了互斥锁objc_sync中的objc_sync_enter和obcj_sync_exit方法。在 Swift 中我们可以仿写一下：func synchronized(_ obj: AnyObject, closure: () -&amp;gt; Void) { objc_sync_enter(obj) closure() objc_sync_exit(obj)}func foo() { ... synchronized(anObj) { ... }}这样就可以简单的给一个对象加锁了。自旋锁 OSSpinLock 作为一个高性能的自旋锁，以前被基础框架广泛使用，但是后来苹果工程师证实一些线程优先级调度算法，会造成优先级翻转问题，造成自旋锁被破坏。作为高性能锁的替换，一些大公司的框架会使用 dispatch_semaphore 、 pthread_mutex 、 NSLock。 dispatch_semaphore GCD 中的信号量，用法简单，在调用wait()时如果信号量为负则会阻断当前线程，实现不同线程的互斥。 let semaphore = DispatchSemaphore(value: 0)func foo() { dispatch_global_async(.default) { sleep(10) semaphore.signal() } semaphore.wait() ...}// orfunc bar() { semaphore.wait(); defer { semaphore.signal() } ... // 方法内是单线程加锁访问的} pthread_mutex 互斥锁 pthread_mutex 是 Linux 和 Mac 系统常用的互斥锁，使用方法与普通互斥锁一样，而已实现线程同步。具体的使用教程可参考 Google。 NSLock NSLock 其实是对 pthread_mutex 的一层封装。 " }, { "title": "Swift Tips (1) - Function", "url": "/posts/Swift-Tips-(1)/", "categories": "Tech", "tags": "Swift", "date": "2018-06-07 15:27:00 +0800", "snippet": "函数的柯里化Swift 里可以将方法进行柯里化 (Currying)，这是也就是把接受多个参数的方法进行一些变形，使其更加灵活的方法。在非函数式的代码时，我们可能会这样写一个方法：func isNumber(_ base: Int, greaterThan target: Int) -&amp;gt; Bool { return base &amp;gt; target}同样的功能如果使用柯里化的函数：func greaterThan(comparer: Int) -&amp;gt; Int -&amp;gt; Bool { return { $0 &amp;gt; comparer }}let greaterThan10 = greaterThan(10);greaterThan10(13) // =&amp;gt; truegreaterThan10(9) // =&amp;gt; false柯里化是一种量产相似方法的好办法。使用函数当做对象我们可以结合函数实现诸多简便的功能，在 Swift 中，函数也是一等公民，利用函数本身的特点，可以更高效的组合出想要的功能。举例：我们可以给Array&amp;lt;Element&amp;gt;添加方法，获取一个contains的(Element) -&amp;gt; Bool的类型的函数输出。extension Array where Element: Equatable { public static func contains&amp;lt;T: Equatable&amp;gt;(in array: [T]) -&amp;gt; (T) -&amp;gt; Bool { return { obj in return (array.filter { $0 == obj }).count &amp;gt; 0 } } public static func notContains&amp;lt;T: Equatable&amp;gt;(in array: [T]) -&amp;gt; (T) -&amp;gt; Bool { return { obj in return !contains(in: array)(obj) } } public func intersection(with other: [Element]) -&amp;gt; [Element] { return self.filter(Array.contains(in: other)) } public func union(with other: [Element]) -&amp;gt; [Element] { return self + other.minus(with: self) } public func minus(with other: [Element]) -&amp;gt; [Element] { return self.filter(Array.notContains(in: other)) }}let contains = Array.contains(in: [1, 2, 3])contains(1) ==&amp;gt; truecontains(4) ==&amp;gt; false[1, 2, 3].intersection(with: [2, 3]) ==&amp;gt; [2, 3][1, 2, 3].minus(with: [2, 3]) ==&amp;gt; [1][1, 2, 3].union(with: [3, 4]) ==&amp;gt; [1, 2, 3, 4]对于任何实现了Equatable的对象集合，都可以使用这些方法做运算。Tuple 元组Tuple 是 Swift 带给我们的新功能，在普通场景下使用的时候，主要有两点功能： 标明含义：自己或其他小伙伴在接收到这个参数时，很容易根据参数标识来分辨元组内的属性含义。switch some { case let x: x.up = ... x.down = ...} 函数的多结果输出：当一个函数想输出多个数据，而数据之间毫无关联，不能结合成一个对象；或信息太少不至于用对象代替时，我们可以使用多元组当做函数的输出。这点跟Go语言的函数多返回值思想很像。func requestCargoInfo(from url: URL) -&amp;gt; (name: String, destination: String) { ... }@autoclosure@autoclosure 可以说是 Apple 的一个非常神奇的创造，因为这更多地是像在 “hack” 这门语言。简单说，@autoclosure 做的事情就是把一句表达式自动地封装成一个闭包 (closure)。这样有时候在语法上看起来就会非常漂亮。比如系统的 precondition 函数，如果我们自己写一个相似功能的：func precondition(_ condition: () -&amp;gt; Bool, _ message: String ...) {...}precondition({ return 2 &amp;gt; 1 }, &quot;true&quot;)但是使用@autoclosure之后，如系统的：public func precondition(_ condition: @autoclosure () -&amp;gt; Bool, _ message: @autoclosure () -&amp;gt; String = default, file: StaticString = #file, line: UInt = #line)// 我们就可以更简洁的使用：precondition(2 &amp;gt; 1, &quot;true&quot;)另一种使用方式，在 Vapor 源码中，为了避免过度使用资源、耗费性能，通常是确定某个条件之后再使用某个属性。比如这段代码：public func unwrap(or error: @autoclosure @escaping () -&amp;gt; Error) -&amp;gt; Future&amp;lt;Expectation.WrappedType&amp;gt; { return map(to: Expectation.WrappedType.self) { optional in guard let wrapped = optional.wrapped else { throw error() } return wrapped }}这里 Error 是在 optional 确定不为 nil 之后再生成的。最后要提一句的是，@autoclosure 并不支持带有输入参数的写法，也就是说只有形如 () -&amp;gt; T 的参数才能使用这个特性进行简化。" }, { "title": "RxSwift 在工程中的应用", "url": "/posts/RxSwift%E5%9C%A8%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/", "categories": "Tech, FRP", "tags": "Swift, RxSwift, FRP", "date": "2018-06-07 15:08:00 +0800", "snippet": "RxSwift在工程中的规范化应用在工程中使用 RxSwif 和 RxCocoa 之后，遇到了不少问题，从这些问题中总结出了一些优化点和需要注意的地方，作为讨论和以后编码时的指导。简化 Observable 功能Observable 用来描述一个操作的流程，简单可以描述为：输入-&amp;gt;执行-&amp;gt;输出 * n-&amp;gt;结束。对于一个 Observable 来说，他的执行部分代码需要执行尽量少的功能代码，如果功能较为庞大则可以考虑拆分为不同的功能。这样优点是显而易见的，对于函数式编程来说，功能越简单的函子(functor)越能组合出越多功能越复杂的函数。第二，这种小功能的函数也更方便测试和定位问题，同时使代码结构更好，代码可读性更强。例子：获取邮件的操作流程如下，如果展开所有功能，代码是这样的，首先会检查网络，再检查账号登录情况，再去拉取 message，返回拉取的数据。func fetchMailsOb(of folderPath: String) -&amp;gt; Observable&amp;lt;IMAPResult&amp;lt;[MCOIMAPMessage]&amp;gt;&amp;gt; { if Utils.netIsReachable { // check acount: if IMAPManager.shared.checkAccount(username: user, password: pass) { // do something return IMAPManager.shared .fetchLatestMessages(expectedNumber: kMaxMessage, folder: folder) .map({ (messages) -&amp;gt; IMAPResult&amp;lt;[MCOIMAPMessage]&amp;gt; in return IMAPResult.succ(messages) }) } else { return .error(Errors.CheckAccountError) } } else { return .just(IMAPResult.failed(Errors.Request.noNetworkError)) }}根据我们的简化原则，可以把网络检查、账号检查再封装成单独的 Observable 再进行使用：func reachabilityChecking() -&amp;gt; Observable&amp;lt;Void&amp;gt; {...} // throw error when not reachablefunc IMAPAccountChecking() -&amp;gt; Observable&amp;lt;Void&amp;gt; {...} // throw error when failed.func fetchMailsOb(of folderPath: String) -&amp;gt; Observable&amp;lt;IMAPResult&amp;lt;[MCOIMAPMessage]&amp;gt;&amp;gt; { return reachabilityChecking() .flatMap { IMAPAccountChecking() } .flatMap { IMAPManager.shared.fetchLatestMessages(expectedNumber: kMaxMessage, folder: folder) } .map({ (messages) -&amp;gt; IMAPResult&amp;lt;[MCOIMAPMessage]&amp;gt; in return IMAPResult.succ(messages) }) .catchError { .just(IMAPResult.failed($0)) }}这样就简化了fetchMailOb(of:)这个函数，可读性更强，并且网络检查、账号检测的方法同时可以提供给其他函数进行使用，提高复用性减少代码量。错误处理尽量使用 Observable.errorRx给我们提供了统一的错误处理报告机制，他是一种阻断式的处理方式，在链式流里当其中一个操作发生错误，则整个链式流终止。a.flatMap { _ in b }.flatMap { _ in c } // 如果b throw了一个error1，则 Observable 将收到一个 Error Event(error1)。统一使用的好处是，可以规范应用内的错误处理机制。如果不同模块间定义了多种错误类型，如：MyResult.failed(Error), YourResult.error(Error)，在运算或结合函数时，难免做类型转换和判断，带来不必要的代码量。在获取到 Error 之后也更容易使用catchError或do(onError:)来做一些统一处理。 特殊情况：在实际需求中可能出现，a 的错误则弹 Toast 提示，b 的错误则弹 Alert，c 的提示则不响应。这种情况则在创建链式操作流时做区分操作：a.do(onError: { toast(...) }) .flatMap{ _ in b } .do(onError: { alert() }) .flatMap { _ in c }使用值类型传递数据在实际使用函数时，经常会用到闭包，从而会涉及到引用类型和值类型的使用。引用类型则要注意循环引用引起的内存泄露。var ref = ClassA()operation .flatMap { [weak ref] rst in return information(with: rst.first, in: ref) }这样的话还是会在特定条件下遇到问题，比如多线程时，多个线程同时使用引用对象 ref，因为 Swift 中 var的引用对象并不是线程安全的，所以可能会造成读写数据的不可靠，而且多线程下更消耗资源。如果不可避免的使用引用类型，则需要注意这些问题。值类型则不用顾虑这么多，闭包的上下文捕捉、赋值都是基于拷贝的，并且会有编译优化。使用 shareReplay() , share() 提高效率如果使用非连接式的 Observable，则多次订阅会造成 Observable 的多次调用。这时候我们不想重复触发，可以选择使用publish(),replay(),share(),shareReplay()等方式共享订阅者。 shareReplay(n)可以让观察者共享一个源，并且回放n个订阅事件。 share()与shareReplay()区别是，在订阅后，不会受到订阅之前的信号。 RxRealm使用实际使用中经常用到监听数据库对象的数据变化，从而触发某些业务逻辑或反应到界面上。 对于监听列表，可以使用Observable.collection(from:synchronousStart:)：let realm = try! Realm()let laps = realm.objects(Lap.self)Observable.collection(from: laps) .map { laps in &quot;\\(laps.count) laps&quot; } .subscribe(onNext: { text in print(text) }) 监听单个对象，或指定其某个属性： Observable.from(object: ticker, properties: [&quot;name&quot;, &quot;id&quot;, &quot;family&quot;]) 注意事项：在注册 notification 时（监听变化），realm 会进入 write transaction，所以在开始监听的时候要注意写冲突。 add() and delete()Rx式的写操作：let realm = try! Realm()let messages = [Message(&quot;hello&quot;), Message(&quot;world&quot;)]Observable.from(messages) .subscribe(realm.rx.add())let allMessages = realm.objects(Message.self)Observable.from(allMessages) .subscribe(realm.rx.delete()) TableView, CollectionView 数据绑定使用库 RxRealmDataSources，可以简单的建立 DataSource，直接绑定数据到 TableView 或 CollectionView 上。// 无动画可以直接使用 bindTo:Observable.from( [Realm collection] ) .bindTo(tableView.rx.items) {tv, ip, element in let cell = tv.dequeueReusableCell(withIdentifier: &quot;Cell&quot;)! cell.textLabel?.text = element.text return cell } .addDisposableTo(bag)// 包含动画：// create data sourcelet dataSource = RxTableViewRealmDataSource&amp;lt;Lap&amp;gt;( cellIdentifier: &quot;Cell&quot;, cellType: PersonCell.self) {cell, ip, lap in cell.customLabel.text = &quot;\\(ip.row). \\(lap.text)&quot;}// RxRealm to get Observable&amp;lt;Results&amp;gt;let realm = try! Realm()let lapsList = realm.objects(Timer.self).first!.lapslet laps = Observable.changeset(from: lapsList)// bind to table viewlaps .bindTo(tableView.rx.realmChanges(dataSource)) .addDisposableTo(bag)线程使用如果某些操作过于耗时或消耗资源，我们通常会建立独立的线程用来执行这些工作。在 Rx 中我们使用 observeOn: 和 subscribeOn: 来分配工作在指定的线程：observeOn: 和 subscribeOn: 的区别是，observeOn 只保证观察对象的回调在指定的线程，而 subscribeOn: 则会把订阅和非订阅的逻辑都放在指定线程执行。let a = Observable.just(1)let b = Observable.just(2)a .flatMap { _ -&amp;gt; Observable&amp;lt;Int&amp;gt; in print(&quot;logic on: \\(Thread.current)&quot;) return b } .subscribeOn(ConcurrentDispatchQueueScheduler.init(qos: .default)) .subscribe { (event) in print(&quot;\\(event), \\(Thread.current)&quot;) } .disposed(by: bag)// output:logic on: &amp;lt;NSThread: 0x600000264040&amp;gt;{number = 3, name = (null)}next(2), &amp;lt;NSThread: 0x600000264040&amp;gt;{number = 3, name = (null)}completed, &amp;lt;NSThread: 0x600000264040&amp;gt;{number = 3, name = (null)}a .flatMap { _ -&amp;gt; Observable&amp;lt;Int&amp;gt; in print(&quot;logic on: \\(Thread.current)&quot;) return b } .observeOn(ConcurrentDispatchQueueScheduler.init(qos: .default)) .subscribe { (event) in print(&quot;\\(event), \\(Thread.current)&quot;) } .disposed(by: bag)// output:logic on: &amp;lt;NSThread: 0x600000074080&amp;gt;{number = 1, name = main} -&amp;gt; 逻辑处理在主线程next(2), &amp;lt;NSThread: 0x6000002611c0&amp;gt;{number = 5, name = (null)}completed, &amp;lt;NSThread: 0x6000002611c0&amp;gt;{number = 5, name = (null)}使用 subscribeOn: 情况下，在操作链中任意一个地方调用，预期结果都是一样的。observeOn: 则只会影响它之后的数据操作。混合调用 subscribeOn: 和 observeOn: 会导致切换线程:let a = Observable&amp;lt;Int&amp;gt;.create { (observer) -&amp;gt; Disposable in print(&quot;a create on: \\(Thread.current)&quot;) observer.onNext(1) observer.onCompleted() return Disposables.create()}let b = Observable.just(2)a .flatMap { _ -&amp;gt; Observable&amp;lt;Int&amp;gt; in print(&quot;logic on: \\(Thread.current)&quot;) return b } .subscribeOn(ConcurrentDispatchQueueScheduler.init(qos: .default)) .observeOn(ConcurrentDispatchQueueScheduler.init(qos: .default)) .subscribe { (event) in print(&quot;\\(event), \\(Thread.current)&quot;) } .disposed(by: bag)// output:a create on: &amp;lt;NSThread: 0x600000266840&amp;gt;{number = 5, name = (null)}logic on: &amp;lt;NSThread: 0x600000266840&amp;gt;{number = 5, name = (null)}next(2), &amp;lt;NSThread: 0x600000265c80&amp;gt;{number = 4, name = (null)}completed, &amp;lt;NSThread: 0x600000265c80&amp;gt;{number = 4, name = (null)} 如果要在其他线程使用 realm 数据库对象，则需要在闭包中重新获取对象。Side-effects（副作用）首先说明下什么是副作用。如果一个函数被认为包含副作用，则它除了返回一个值之外，还会造成其他可观察的效应。通常来说这个效应是指状态的改变，可能为下面情况： 更改了一个在大于函数当前范围（scope）的变量。 文件或网络的I/O操作 更新了界面信息举个简单的例子：var i = 0let observable = Observable.from([1,2,3]) .map { ele in i += 1 return ele + i }observable.subscribe(on: { event in if case let Event.next(result) = event { print(&quot;observer a:\\(result)&quot;) }}).disposed(by: bag)// output:observer a:2observer a:4observer a:6observable.subscribe(on: { event in if case let Event.next(result) = event { print(&quot;observer b:\\(result)&quot;) }}).disposed(by: bag)// output:observer b:5observer b:7observer b:9副作用有可能是偶然的，也有可能是有意为之的。简单来说避免副作用的方式是，尽量在函数内避免改变其他变量或状态。为什么要避免这种副作用？ 使代码更具可维护性(maintainability),一个高性能、高可维护性的函数应该确定输入和输出的逻辑性，如果函数中包含不确定的可变元素，可能导致同样的输入产出不同的结果。这对其他使用者来说会造成疑惑甚至是 bug。 函数改变了公共属性或状态，这些属性和状态则对于其他人来说可能是不可预知的。 不方便测试。怎么解决副作用，我们可以把状态或者值当做一个函数的一个参数来改造函数：func increase(of array: [Int]) -&amp;gt; Observable&amp;lt;Int&amp;gt; { let indeces = 0..&amp;lt;array.count return Observable.from(indeces) .map { index in return array[index] + index }}这样这个函数就保证了不管谁调用，输入输出都是可控的。创建易于测试的代码下面的代码可能是我们平常经常编写的：func someFunction() -&amp;gt; Observable&amp;lt;String&amp;gt; { return otherOb.map { result in return result + GlobalInstance.property1 } ...}GlobalInstance.property1 可能是工程中的全局变量，在我们意识到这个变量是测试条件之前，直接在函数中使用是合理的。这样的代码在平常运行和阅读时没有任何问题，但是如果在测试时，GlobalInstance.property1 成为测试条件之一时，这个方法就变得不可测试了。简单的做法是，在写一个函数时，可以优先考虑下这个函数的功能和测试条件，尽量把测试条件当做可变参数进行构建：func someFunction(with param: String) -&amp;gt; Observable&amp;lt;String&amp;gt; { return otherOb.map { result in return result + param } ...}这样的话，可以根据不同的测试条件设定函数的输入来测试函数的正确性。如果输入条件比较复杂，可以根据实际分类来规整出协议，提高可读性和可维护性：func someFunction(with info: ProtocolA &amp;amp; ProtocolB) -&amp;gt; Observable&amp;lt;String&amp;gt; { return otherOb .map { result in return result + info.property1 + info.property2 }}func test() { let scenarioA: (ProtocolA &amp;amp; ProtocolB) = ... let scenarioB: (ProtocolA &amp;amp; ProtocolB) = ... someFunction(with: scenarioA) .subscribe(onNext: { ele ... }) .dispose(by: bag) someFunction(with: scenarioB) .subscribe(onNext: { ele ... }) .dispose(by: bag)}" }, { "title": "Learning ReactiveSwift - Part 2", "url": "/posts/Learning-ReactiveSwift-Part-2/", "categories": "Tech, FRP", "tags": "Swift, FRP, ReactiveSwift", "date": "2017-07-04 20:00:00 +0800", "snippet": "数据流FRP之前一篇已经介绍过，是一种抽象的数据流型的编程思想。对于数据流，开始一个数据流后，会产生很多事件。在ReactiveSwift中，定义的事件有Event、Error。对应Observer则会有observe value、failed、complete、interrupted。对于冷信号：let observer = Signal&amp;lt;Int, NSError&amp;gt;.Observer( value: { print(&quot;value: \\($0)&quot;) }, failed: { print(&quot;failed with \\($0)&quot;)}, completed: { print(&quot;complete&quot;) }, interrupted: { print(&quot;interupted&quot;) })SignalProducer&amp;lt;Int, NSError&amp;gt;([1,2,3,4]).start(observer)/*print:value: 1value: 2value: 3value: 4complete */ // orlet producer = SignalProducer&amp;lt;Int, NSError&amp;gt;([1, 2, 3, 4])producer.startWithSignal { (signal, disposable) in signal.observe({ (event) in switch event { case .value(let value): print(&quot;value: \\(value)&quot;) case .failed(let error): print(&quot;failed with \\(error)&quot;) case .interrupted: print(&quot;interrupted&quot;) case .completed: print(&quot;completed&quot;) } })}对于热信号：let (signal, observer) = Signal&amp;lt;String, TestError&amp;gt;.pipe()signal.observe { event in switch event { case .value(let value): print(&quot;value: \\(value)&quot;) case .failed(let error): print(&quot;failed with \\(error)&quot;) case .interrupted: print(&quot;interrupted&quot;) case .completed: print(&quot;completed&quot;) }}需要注意的是，在signal接收到failed, interrupted, complete事件后，该通道就相当于关闭了，之后的事件则不会再接收到。Mapmap就像一般函数式编程中map用法一样，对sequence内对象进行transform，如下面例子，对数组中的数进行乘2：SignalProducer&amp;lt;Int, NoError&amp;gt;([1, 2, 3, 4]) .map { $0 * 2 } .startWithValues { print($0) }// print: // 2 4 6 8mapError是对failed情况进行transform：enum TestError: Error { case code(Int)}SignalProducer&amp;lt;Int, NSError&amp;gt;(error: NSError(domain: &quot;test.domain&quot;, code: 100, userInfo: nil)) .mapError { return TestError.code($0.code) } .startWithFailed { (error) in switch error { case let .code(code): print(code) }}// print: 100flatMap是对SignalProducer进行转换SignalProducer&amp;lt;Int, NoError&amp;gt;([ 1, 2, 3, 4 ]) .flatMap(.latest) { SignalProducer(value: $0 + 3) } .startWithValues { value in print(value)}/*print:4567*/Filter对Value进行过滤，只有符合条件的value才能触发事件:SignalProducer&amp;lt;Int, NoError&amp;gt;([ 1, 2, 3, 4 ]) .filter { $0 &amp;gt; 3 } .startWithValues { value in print(value) }// print: 4Take取事件的前N项（take(first:)）或后N项(take(last:))let producer = SignalProducer&amp;lt;Int, NSError&amp;gt;([1, 2, 3, 4])producer .take(last: 2) .startWithResult { print($0) }// .success(3)// .success(4)CombinecombineLatest是把第一个producer的最后一项与第二个producer的value进行绑定：let producer1 = SignalProducer&amp;lt;Int, NoError&amp;gt;([ 1, 2, 3, 4 ])let producer2 = SignalProducer&amp;lt;Int, NoError&amp;gt;([ 1, 2 ])producer1 .combineLatest(with: producer2) .startWithValues { value in print(&quot;\\(value)&quot;)}// print:// (4, 1)// (4, 2)combinePrevious是每次value都绑定前一次event的valueSignalProducer&amp;lt;Int, NoError&amp;gt;([ 1, 2, 3, 4 ]) .combinePrevious(42) .startWithValues { value in print(&quot;\\(value)&quot;)}/* print :(42, 1)(1, 2)(2, 3)(3, 4)*/小结对于SignalProducer和Signal，还有很多方便的小工具对其进行操作或者转换，在实际使用过程中根据需求的不同进行使用。" }, { "title": "Learning ReactiveSwift - Part 1", "url": "/posts/Learning-ReactiveSwift-Part-1/", "categories": "Tech, FRP", "tags": "Swift, FRP, ReactiveSwift", "date": "2017-04-24 19:18:00 +0800", "snippet": " RAC 4.0发布以后发现，RAC进行了大量的更新，其中最主要的是使用了ReactiveSwift作为基础库，替换掉了以前OC版的库，RAC则是对于RAS和Cocoa框架的封装。入门对于以前的RAC教程，理论部分大部分还是通用的，但是ReactiveSwift在某些方面进行了重构和修改，而且现有教程缺乏更新，不得已我们重头来梳理遍ReactiveSwift的入门教程。ReactiveSwift的文档是一篇不错的入门介绍，本文部分直接翻译自原文。什么是ReactiveSwiftReactiveSwift提供了可组合的、宣言式的、灵活的基元，用来构建数据流（streams of values），这种形式是Reative Programming的重要表现之一。ReactiveSwift使用的是Functional Reactive Programming(FRP)，FRP是两种概念的结合，Reactive Programming和Functional Programming。Reactive Programming是专注于监听异步数据流，并且可以作出相应反馈的一种编程方式。可以查看这篇文章的详细介绍。Functional Programming强调使用数学模型的函数来计算，特点是不可变、而又表达明确清晰，最小化使用变量和状态。理解先来看看ReactiveSwift的几个重要基元：Signal, SignalProducer, Event, Observer, Action.当一个对象持有一个Signal，可以看做，一家电视台有在某个频道的电视节目，Signal就是这个频道（通道）。Event，可以看做是这个频道上的数据。Observer则是电视观众，他们订阅（subscribe或observe）了这个频道（signal)，则可以从频道中获取内容（events）。Action则是一种动作，对Signal产生影响，却不对Signal的持有者产生影响，就像：换台（sendInterrupt）。而Signal和SignalProducer则是RAC更新中的一个变动，他俩的定义就像“冷、热信号”。在Rx和RAC 2.x以前他们是统一一起的。之所以分开，官方文档的解释是： … it is impossible to tell whether subscribing to (observing) that IObservable will involve side effects. If it does involve side effects, it’s also impossible to tell whether each subscription has a side effect, or if only the first one does. This example is contrived, but it demonstrates a real, pervasive problem that makes it extremely hard to understand Rx code (and pre-3.0 ReactiveCocoa code) at a glance. ReactiveSwift addresses this by distinguishing side effects with the separate Signal and SignalProducer types. Although this means there’s another type to learn about, it improves code clarity and helps communicate intent much better. In other words, ReactiveSwift’s changes here are simple, not easy.简单来说，监听或订阅一个信号，可能会产生副作用，为了区分是否产生副作用，ReactiveSwift区分了两个类型。Signal vs. SignalProducer为了理解Signal和SignalProducer之间的区别，我门可以举一个传统电视节目和视频网站的例子。Signal的表现就像是电视节目一样，是一个连续的视频流和音频流。在一个固定的时间点，每个观众看到的电视节目内容都是一样的。观众既不能向电视节目内容内插入事件（副作用），也不能命令电视节目开始和结束。观众只能开始或停止接受电视节目内容。另一方面，SignalProducer像是一个视频网站的视频流，就像 YouTube 一样。观众可以收到视频和音频的数据流，但是每个不一样的观众在同一时间点收到的内容是不一样的。同时观众可以主动开启和关闭他观看的视频。因此，Signals 通常是用来表示一个正在进行中的事件流，像是广播、用户输入等。另一方面，SignalProducers 通常表示一个需要被主动开启的操作或者任务。例如网络请求，每一次调用start都会开启一个新的操作，。这个例子中如果使用了 Signal，结果是所有在网络请求响应回来之前，开始监听当前Signal的观察者，都会收到网络请求回调。来源： To understand the difference between Signal and SignalProducer, let’s take the analogy of TV and on-demand streaming service. Signal behaves like a TV feed which is a continuous stream of video and audio. At a given point of time, every observer of the TV feed sees the same sequence of the frame. The observer neither can inject any side effect to TV feed, nor it can start or stop the feed. The observer can only start and stop receiving the feed. On the other hand, SignalProducer is like an on demand streaming service like YouTube. Here, the observer can receive a stream of video and audio, but the sequence of the stream is different for a different observer. Here the observer can start and stop the feed. Therefore, Signals are generally used to represent event streams that are already “in progress,” such as notifications, user input, etc. SignalProducers, on the other hand, are used to represent operations or tasks which need to be started. For example, like network requests, where each invocation of start will create a new underlying operation. In the case of a Signal, the results might be sent before any observers are attached. In the case of a SignalProducer, the results are not sent unless it is started.简单使用ReactiveSwift 了解基础用法，其实可以下载ReactiveCocoa源码工程，在单元测试中可以找到API的各种用法。下面源码大部分取自单元测试代码。Signal// 使用一段代码（运行）let disposable = SimpleDisposable()let signal: Signal&amp;lt;Int, NoError&amp;gt; = Signal { observer in // do something return disposable}signal.observe { event in switch event { case let .value(number): // do something case .completed: // do completion default: break }}// 使用pipe()let (signal, observer) = Signal&amp;lt;String, TestError&amp;gt;.pipe()// 同样可使用observesignal.observe { event in // blabla}// observer可以send eventsobserver.send(value: &quot;a string&quot;)observer.sendCompleted()SignalProducerSignalProducer是触发式的var disposable: Disposable!let producer = SignalProducer&amp;lt;Int, NoError&amp;gt; { observer, innerDisposable in disposable = innerDisposable innerDisposable += { observer.send(value: 1) } observer.send(value: 0)}producer.startWithSignal { signal, disposable in signal.observeValues { print($0) }}disposable.dispose()// print:// 0// 1Disposable看到上面SignalProducer和Signal的例子，用到Disposable的场景。Disposable是由协议Disposable描述的，拥有内存管理和取消机制一种对象。当启动一个Signal producer，会返回一个disposable对象，这个对象可被用作取消被启动的工作，清理所有临时资源，然后发送一个interrupted事件（Event）给被创建的Signal。监听（Observer）一个Signal也会返回一个disposable对象，用来使监听者停止从Signal接收events，但是不会对Signal产生影响。Events事件，描述一个发生的事情。在ReactiveSwift中，事件是通讯的核心部分。一些事件生成器可以通过Signal发送事件给注册的观察者们。Unidirectional Binding单向绑定，通过一个数据源（BindingSource）绑定到一个目标（BindingTargetProvider）上。public func &amp;lt;~&amp;lt;Provider, Source&amp;gt;(provider: Provider, source: Source) -&amp;gt; Disposable? where Provider : BindingTargetProvider, Source : BindingSource, Source.Error == Result.NoError, Source.Value == Provider.Value有定义可见，只要Source和Provider的Value是同一类型，就可以进行绑定。举个例子：var value: Int? = nil let (lifetime, _) = Lifetime.make()let target = BindingTarget&amp;lt;Int&amp;gt;(lifetime: lifetime) { value = $0 }let property = MutableProperty.init(1) target &amp;lt;~ property// value = 1property.value = 2// value = 2 这例子是单元测试的例子，但是我自己试的时候value一直是nil…不知道那出了问题。Lifetime生命周期的监控，比如：let object = MutableReference(TestObject())var isEnded = falsevar isCompleted = falseobject.value!.ended.observeCompleted { isCompleted = true }object.value!.lifetime.observeEnded { isEnded = true }expect(isCompleted) == falseexpect(isEnded) == falseobject.value = nilexpect(isCompleted) == trueexpect(isEnded) == trueTake a break这篇主要是讲一些ReactiveSwift的基础用法，下篇主要讲他的函数式部分，比如map、filter等。" }, { "title": "POP, 泛型和函数式思想在iOS中的应用", "url": "/posts/POP-%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E6%80%9D%E6%83%B3%E5%9C%A8iOS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/", "categories": "Tech, Functional Swift", "tags": "POP, Functional", "date": "2017-04-01 13:00:00 +0800", "snippet": "什么是POP (Protocol-oriented-programing) 在我们平常工作中，经常使用的是OOP（Object-Oriented-Programing），比如C++、OC、JAVA。他们是把一些数据或动作集合当做一个对象来看待，比如树、人、机器等。POP则不同，它从另一个视角看待事物：属性。一个对象拥有的数据属性和动作属性，都可以成为一种协议（protocol），不同的对象间有着共同的协议或相似的协议。 实际编码过程中，定义各种协议来规范和拓展类的方式，统称叫做POP。举个🌰以前我们可能会这样构建一个类：class bird { var name = &quot;&quot; var canFly = true}class penguin: bird { override init() { super.init() self.canFly = false self.name = &quot;penguin&quot; }}对于OOP来说是这样定义的，bird为penguin的父类，子类继承和覆盖了父类的属性。而在POP中，我们这么干:protocol Flyable { var canFly: Bool { get }}struct Plane: Flyable { var canFly: Bool = true}struct Swallow: Flyable { var canFly: Bool = true}明显Flyable属性其实不单独属于鸟类，它同样也是很多其他对象的属性。所以在构造其他对象时，我们可以给他们贴上同样的“标签”，接下来我们试着丰富一下我们的标签。我们定义一个可以描述速度的协议：protocol Racer { var speed: Double { get }}extension Plane: Racer { var speed: Double { return 1000 }}extension Swallow: Racer { var speed: Double { return 200 }}这样，我们的✈️和🐦就拥有速度了~ 然后我们可以用Racer来进行拓展。拓展一个很简单的功能，我们知道Array是继承Sequence协议的，我们可以在Sequence中加入一个功能，使得快速找出Sequence中速度最快的对象。extension Sequence where Iterator.Element == Racer { func fastest() -&amp;gt; Iterator.Element? { return self.max(by: { (a: Iterator.Element, b: Iterator.Element) -&amp;gt; Bool in return a.speed &amp;lt; b.speed }) }}let plane = Plane()let swallow = Swallow()let array: Array&amp;lt;Racer&amp;gt; = [plane, swallow]array.fastest()这样Array就具有了一个简单的功能，我们可以利用这种思想去构建一个体系，Swift中的Array和Dictionary就是很好的例子。Pop的简单应用先来看一个简单的例子，iOS的TableView我们通常这样写：class CommentCell: UITableViewCell {}class MyViewcontroller: UIViewController, UITableViewDelegate, UITableViewDataSource { var tableView = UITableView() override func viewDidLoad() { super.viewDidLoad() let cellNib = UINib(nibName: &quot;CommentCell&quot;, bundle: nil) tableView .register(cellNib, forCellReuseIdentifier: &quot;comment_cell&quot;) } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell { guard let cell = tableView.dequeueReusableCell(withIdentifier: &quot;comment_cell&quot;, for: indexPath) as? CommentCell else { return UITableViewCell() } return cell; }}这看起来有点复杂，夹杂着各种判断和转换。所以我们可以利用Swift的特性和POP方式：protocol ReusableView {}extension ReusableView where Self: UITableViewCell { static var reusedIdentifier: String { return String(describing: self.self) }}protocol NibLoadableView: class { }extension NibLoadableView where Self: UIView { static var NibName: String { return String(describing: self.self) }}extension CommentCell: ReusableView, NibLoadableView {}有了这两个协议，我们就可以对TableView的方法进行改造，使用泛型方法：extension UITableView { func registerNib&amp;lt;T: UITableViewCell&amp;gt;(_: T.Type) -&amp;gt; Void where T: ReusableView, T: NibLoadableView { let nib = UINib(nibName: T.NibName, bundle: nil) self.register(nib, forCellReuseIdentifier: T.reusedIdentifier) } func dequeReusableCell&amp;lt;T: UITableViewCell&amp;gt;(forIndexPath ip: IndexPath) -&amp;gt; T where T: ReusableView { guard let cell = self.dequeueReusableCell(withIdentifier: T.reusedIdentifier, for: ip) as? T else { fatalError(&quot;couldn&#39;t deque cell with identifier: \\(T.reusedIdentifier)&quot;) } return cell }}然后在实现的时候，我们会发现一切变得更好了extension MyViewcontroller { func register() -&amp;gt; Void { tableView.registerNib(CommentCell.self) } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell { return tableView.dequeReusableCell(forIndexPath: indexPath) as CommentCell }}这只是个实例，这种思想并不会一定帮助你的代码效率更高，但是合理利用下，会让你的代码可读性变得很强，拓展性变的极高，思路变得清晰。下面我们看看在实际项目中POP的应用。一个网络层框架这个是一个项目中实际使用的网络请求框架。在父类的APIManager中包含了一个指向子类的指针，并且强制子类实现一个APIManagerProtocol。父类初始化时要求子类的约束条件。- (instancetype)init { if (self = [super init]) { if ([self conformsToProtocol:@protocol(XLAPIManagerProtocol)]) { self.child = (id &amp;lt;XLAPIManagerProtocol&amp;gt;)self; self.shouldAutoRetry = [self.child respondsToSelector:@selector(autoRetryCountWithErrorCode:)]; self.autoProcessReceivedData = YES; } else { NSAssert(NO, @&quot;APIManager 子类必须集成XLAPIManagerProtocl&quot;); } } return self;}利用self.child来规范子类的实现，同时通过protocol来获取子类的相关信息，使功能实现聚合在BaseAPI中。比如这个获取完整URLString的方法：- (NSString *)fullURLString { if (!self.urlString) { NSMutableString *url = [NSMutableString stringWithString:[self.child server].url]; if ([self.child apiVersion] &amp;amp;&amp;amp; [self.child apiVersion].length &amp;gt; 0) { [url appendFormat:@&quot;/%@&quot;, [self.child apiVersion]]; } [url appendFormat:@&quot;/%@&quot;, [self.child apiName]]; self.urlString = url; } return self.urlString;}实现后我们会发现，子类实现API会非常清晰和简洁。一个API类的实现，只需要几行代码@implementation KNBindInfoAPIManager- (NSString *)apiName { return @&quot;bindinfo&quot;;}- (NSString *)apiVersion { return @&quot;&quot;;}- (NSString *)httpMethod { return @&quot;GET&quot;;}- (XLServer *)server { return [XLVipExtServer sharedServer];}@end在以前的错误码处理中，都是统一在APIManager中处理。但是后来遇到一个问题，由于请求的服务器不同，导致错误码处理不一致，再看我们之前的实现，就有点代码的坏味道了。分析后发现，错误码其实是和服务器挂钩，真正该如何处理一个数据应该是由该服务器说了算，所以我们给XLServer这个类加了一个协议：@protocol XLServerDataProcessProtocol &amp;lt;NSObject&amp;gt;/** * 处理数据，可抛出异常或请求重试。 * * @param data 要处理的数据 * @param error 错误 * @param retry 是否需要重试 */- (void)handleData:(id)data error:(NSError **)error shouldRetry:(BOOL *)retry;// 在父APIManager.m 实现中if ([self.child.server conformsToProtocol:@protocol(XLServerDataProcessProtocol)]) { NSError *error = nil; BOOL retry = NO; [(id &amp;lt;XLServerDataProcessProtocol&amp;gt;)self.child.server handleData:responseObject error:&amp;amp;error shouldRetry:&amp;amp;retry]}在API处理结果中，对当前子类的server进行判断，如果有响应协议，则交给相应服务器对象处理。这些在Objective-C中的实践例子，实际用处是规范了各个类的数据和动作的实现，使得代码结构变得清晰，逻辑严密。简谈函数式编程 在Swift中，函数成为了First class value，使得我们可以传递、使用函数就像使用一个数字、一个字符串一样简单。 可以粗略的看待一个函数，就是一个过程。 我们可以通过变换函数，创造一个个“小工具”，这些工具可以帮助我们构建复杂的过程。 函数方便我们调试和找出bug一个简单的函数式思想的例子假如我们写一个战船的例子，我们需要一个方法来定位敌方战船是否在我们的有效射程范围内：typealias Distance = Doublestruct Position { var x: Double var y: Double}extension Position { func inRange(range: Distance) -&amp;gt; Bool { return sqrt(x * x + y * y) &amp;lt;= range }}struct Ship { var position: Position var firingRange : Distance var unsafeRange : Distance}extension Ship { // 最初我们就判断是不是在射程范围里 func canEngageShip(target: Ship) -&amp;gt; Bool { let dx = target.position.x - position.x let dy = target.position.y - position.y return sqrt(dx * dx + dy * dy) &amp;lt;= firingRange } // 发现同时，敌方也不能离我们太近 func canSafelyEngageShip(target: Ship) -&amp;gt; Bool { let dx = target.position.x - position.x let dy = target.position.y - position.y let targetDistance = sqrt(dx * dx + dy * dy) return targetDistance &amp;lt;= firingRange &amp;amp;&amp;amp; targetDistance &amp;gt; unsafeRange } // 友方战船也不能离目标太近 func canSafelyEngageShip1(target: Ship, friendly: Ship) -&amp;gt; Bool { let dx = target.position.x - position.x let dy = target.position.y - position.y let targetDistance = sqrt(dx * dx + dy * dy) let friendlyDx = friendly.position.x - target.position.x let friendlyDy = friendly.position.y - target.position.y let friendlyDistance = sqrt(friendlyDx * friendlyDx + friendlyDy * friendlyDy) return targetDistance &amp;lt;= firingRange &amp;amp;&amp;amp; targetDistance &amp;gt; unsafeRange &amp;amp;&amp;amp; (friendlyDistance &amp;gt; friendly.unsafeRange) }}为了简化计算，我们抽取其中的几个方法：extension Position { func minus(_ p: Position) -&amp;gt; Position { return Position(x: x - p.x, y: y - p.y) } var length: Double { return sqrt(x * x + y * y) }}extension Ship { func canSafelyEngageShip2(target: Ship, friendly: Ship) -&amp;gt; Bool { let targetDistance = target.position.minus(self.position).length let friendlyDistance = friendly.position.minus(target.position).length return targetDistance &amp;lt;= firingRange &amp;amp;&amp;amp; targetDistance &amp;gt; unsafeRange &amp;amp;&amp;amp; (friendlyDistance &amp;gt; unsafeRange) }}最终这个函数表现成这样，看起来条例清晰，逻辑清楚，但是难免在整个函数构建过程中发现，这个过程包含着一次次重构。现在我们换个思路，把这一个关键的判断过程看做一个对象:typealias Region = (Position) -&amp;gt; Bool我们把这个过程定义成一个名为区域的类型。然后我们需要一些工具来生成或者改变区域：func circle(_ radius: Distance) -&amp;gt; Region { return { $0.length &amp;lt;= radius }}func shift(_ region: @escaping Region, offset: Position) -&amp;gt; Region { return { region($0.minus(offset)) }}func invert(_ region: @escaping Region) -&amp;gt; Region { return { !region($0) }}func intersection(_ region1: @escaping Region, _ region2: @escaping Region) -&amp;gt; Region { return { point in region1(point) &amp;amp;&amp;amp; region2(point) }}func union(_ region1: @escaping Region, _ region2: @escaping Region) -&amp;gt; Region { return { point in region1(point) || region2(point) }}func difference(_ region1: @escaping Region, minus: @escaping Region) -&amp;gt; Region { return intersection(region1, invert(minus))}有了这些小工具，我们可以轻松的定义之前的函数extension Ship { func canSafelyEngageShip(target: Ship, friendly: Ship) -&amp;gt; Bool { // 生成自己的安全攻击范围 let rangeRegion = difference(circle(firingRange), minus: circle(unsafeRange)) // 位移一下到战船所处坐标 let firingRegion = shift(rangeRegion, offset: position) // 生成友方的安全范围 let friendlyRegion = shift(circle(friendly.unsafeRange),offset: friendly.position) // 生成实际有效范围 let resultRegion = difference(firingRegion, minus: friendlyRegion) return resultRegion(target.position) }}let me = Ship(position: Position(x: 0, y: 0), firingRange: 100, unsafeRange: 20)let target = Ship(position: Position(x: 77, y: -10), firingRange: 100, unsafeRange: 20)let friendly = Ship(position: Position(x: 59, y: 8), firingRange: 100, unsafeRange: 20)me.canSafelyEngageShip(target: target, friendly: friendly)// output: truePOP、泛型和函数式编程的结合我们可以定义一个操作过程，传入一个参数产生一个结果。这种基础过程遍布我们的应用中：enum Result&amp;lt;T&amp;gt; { case success(T) case failed(Error)}typealias fu_operation&amp;lt;E, T&amp;gt; = (E) -&amp;gt; Result&amp;lt;T&amp;gt;这里定义了一个枚举的结果类型，用泛型表示结果中的实际类型。定义的operation表示输入一个E类型的数据，产生一个Result&amp;lt;T&amp;gt;类型的结果。然后我们可以定义一个combine函数，用于结合两个operation：func combine&amp;lt;E, T, H&amp;gt;(op1: @escaping fu_operation&amp;lt;E, T&amp;gt;, op2: @escaping fu_operation&amp;lt;T, H&amp;gt;) -&amp;gt; fu_operation&amp;lt;E, H&amp;gt; { return { params in let rst = op1(params) switch rst { case .success(let value): return op2(value) case .failed(let e): return .failed(e) } }}测试一下，a是将字典所有key值取出来编程数组的过程，b是把数组转成可读字符串的过程：let a: fu_operation&amp;lt;[String: Any] ,[String]&amp;gt; = { params in return .success( params.reduce([String](), { (rst: [String], couple: (key: String, value: Any)) -&amp;gt; [String] in var newRst: [String] = rst newRst.append(couple.key) return newRst }) )}let b: fu_operation&amp;lt;[String], String&amp;gt; = {params in var str = &quot;&quot; for value in params { str.append(value + &quot; ,&quot;) } return .success(str)}combine(op1: a, op2: b)([&quot;a&quot;: 1, &quot;b&quot;: 2])//输出为：//success(&quot;b ,a ,&quot;)为了方便使用，我们先定义一个类，以后也可以在其中做扩展：class st_operation&amp;lt;E, T&amp;gt; { var op: fu_operation&amp;lt;E, T&amp;gt; = { _ in .failed(NSError())} init() { } init(with operation: @escaping (E) -&amp;gt; Result&amp;lt;T&amp;gt;) { self.op = operation }}以一个数据请求动作为例，拿到的数据通常是JSON转换成的Dictionary，所以我们定义一个协议：protocol ConstructableFromDictionary { static func generate(from dictionary: [String: Any]) -&amp;gt; Self?}接着我们定义我们的API动作，动作有两个操作，一个是发起请求获取源数据，一个是转换元数据到我们定义的模型：typealias Parameters = [String: Any]class API&amp;lt;T: ConstructableFromDictionary&amp;gt; { var requestOperation: st_operation&amp;lt;Parameters, [String: Any]&amp;gt; = st_operation { .success(Request.GET(params: $0)) } var transform: st_operation&amp;lt;[String: Any], T&amp;gt; = st_operation { if let rst = T.generate(from: $0) { return .success(rst) } else { return .failed(NSError()) } } func request(params: Parameters?) throws -&amp;gt; T { // 首先结合两个操作，然后返回其中的结果 let op = combine(op1: self.requestOperation.op, op2: self.transform.op) let result = op(params ?? [:]) switch result { case .success(let value): return value case .failed(let error): throw error } }}假如我们现在需要拉取一个水果的信息，我们可以先定义一个水果的类，使他实现协议：class Fruit: ConstructableFromDictionary { var name: String = &quot;&quot; required init() { } static func generate(from dictionary: [String : Any]) -&amp;gt; Self? { let fruit = self.init() fruit.name = dictionary[&quot;name&quot;] as? String ?? &quot;&quot; return fruit }}这样一来，我们不用写其他任何多余代码，就可以利用基础的API类做到数据请求。let fruitAPI = API&amp;lt;Fruit&amp;gt;()do { let fruit = try fruitAPI.request(params: nil) fruit.name // Get fruit&#39;s name success, yeah} catch { // deal error}总结 Swift带给我们的新体验是Amazing的，虽然POP或IOP概念很早就有，但是结合泛型和函数式编程，学习它而带给我们的是思维上的进化或者革命，让我们拥有更新的视角。 对于iOS而言，实际应用中，OOP和POP混合使用是必不可少的，POP的加入的意义是使代码更规范、灵活，使结构和逻辑更清晰易懂。 以上所有代码都是Swift-Only的，所以在以后跨平台上，Swift和POP会更有优势。当然在iOS上OC还是舍弃不掉的，OC的优势是更灵活的Runtime，实际应用中更需各取所长。写Swift代码也尽量避免rewrite OC code。参考 [B]Functional Swift - Chris Eidhof, Florian Kugler, Wouter Swierstra Practical Protocol Oriented Programming扩展阅读 Functors, Applicatives, And Monads In Pictures" }, { "title": "Transmission Between Weex and iOS Native", "url": "/posts/Transmissioin-between-Weex-and-iOS-native/", "categories": "Tech, Hybrid", "tags": "", "date": "2017-03-24 13:00:00 +0800", "snippet": "Weex 与 iOS Native 的传输在使用Weex时，我们经常需要数据和事件与native之间的交互，多发生于界面事件和数据传输。举个很简单的例子，Weex page中一项内购的页面，需要显示Apple store的价格，此时需要native从服务器拿到价格后发送给weex page做显示。这个过程包括weex发送请求到本地，本地处理回调等。本文主要内容就是，如何实现这一过程及保证统一、低耦合的中间层。实现原理Weex 端发送请求在Weex界面的JS script中，我们能通过调用App注册的模组来直接调用方法。在demo中，处理这一过程的是XLPluginEvent类。在初始化SDK时，通过注册：[WXSDKEngine registerModule:@&quot;mediator&quot; withClass:NSClassFromString(@&quot;XLPluginEvent&quot;)];JS端就可以通过注册的类其中的方法，来发起一个Event：var module = weex.requireModule(&#39;mediator&#39;);module.sendRequestData(data, &#39;pluginA&#39;, &#39;native&#39;, (ret) =&amp;gt; { this.result = ret modal.toast({ message: &#39;receive&#39;, duration: 0.3 })})JS端的function可以以参数传递给native并以block形式调用。这样就实现了JS端发起Event并可以获得回调。Native发起EventsNative端可有两种方式传递events至Weex。 通过WXSDKManager提供的fireEvent:ref:type:params:domChanges:方法。用这个方法可以在weex page上监听到事件，如 [[WXSDKManager bridgeMgr] fireEvent:targetWX.InstanceId ref:@&quot;_root&quot; type:@&quot;nativetransport&quot; params:paramsAddCallback domChanges:nil]; &amp;lt;template&amp;gt; &amp;lt;text onClick=&#39;onClick&#39; onnativetransport=&quot;&quot; id=&#39;text1&#39;&amp;gt;callback: &amp;lt;/text&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; # 上略 nativeTransport: function(e) { console.log(e) } &amp;lt;/script&amp;gt; 通过fireGlobalEvent:params:方法这个方法其实是发送一个全局通知，所有已存在的Weex page都能接收到这个Event，但前提是Weex page初始化时注册listener。 var globalEvent = require(&#39;@weex-module/globalEvent&#39;)globalEvent.addEventListener(&quot;nativetransport&quot;, (e) =&amp;gt; { console.log(e) this.result = &quot;native send a request&quot;}) 这时native调用fireEvent就可以触发这个监听事件。 中间层建立中间层的目的是统一对所有Weex page的events做转发，一来是方便做hook，二来是防止plugin与plugin之间互相直接调用产生耦合。如果没有统一的中间层和派发关系，想象一下维护过N个版本之后的杂乱无章的调用关系…梳理下我们期待的流程图：绑定事件每个Weex instance都可以绑定module来处理事件，所以module的实例也是分散形式的。我们用统一的类XLPluginEvent来收集信息，并将信息转到统一的中间层类XLWxPluginMediator做处理。[WXSDKEngine registerModule:@&quot;mediator&quot; withClass:NSClassFromString(@&quot;XLPluginEvent&quot;)];// In XLPluginEvent class:- (void)sendRequestData:(NSDictionary *)data from:(NSString *)source toTarget:(NSString *)target callback:(WXModuleCallback)callback { [[XLWxPluginMediator sharedInstance] sendRequestData:data from:weexInstance source:source toTarget:target callback:callback];}中间处理XLWxPluginMediator同时具有接收和发送功能。接收event之后会根据event附带的information，做本地分发或插件分发，一般用target标明event的目标对象。- (void)sendRequestData:(NSDictionary *)data from:(WXSDKInstance *)wx source:(NSString *)source toTarget:(NSString *)target callback:(WXModuleCallback)callback { if ([target isEqualToString:@&quot;native&quot;]) { // Notify all native listeners } else { // 1 . find target// WXSDKInstance *target = [Finder findtarget]; // 2 . fire a event &amp;amp; wait to callback// [self sendEventTo:target params:data callback:callback]; }}native向plugin做通信请求暂时是通过fireGlobalEvent方法实现的，原因是使用fireEvent会与界面绑定，某些场合我们并不需要与界面绑定。- (void)sendEventTo:(WXSDKInstance *)wx params:(NSDictionary *)params callback:(WXModuleCallback)callback { NSMutableDictionary *paramsAddCallback = [NSMutableDictionary dictionaryWithDictionary:params]; [paramsAddCallback setObject:callback forKey:@&quot;callback&quot;]; [wx fireGlobalEvent:@&quot;nativetransport&quot; params:paramsAddCallback];}拥有响应native event的plugin必须在onCreate里实现这个event的监听：created: function () { var globalEvent = require(&#39;@weex-module/globalEvent&#39;) globalEvent.addEventListener(&quot;nativetransport&quot;, (e) =&amp;gt; { console.log(e) }) },由此就实现了plugin与native之间的双向传输。Plugins 之间的传输// TODO: - " }, { "title": "Nginx Deployment on Mac OS", "url": "/posts/Nginx-depoloyment-on-Mac-OS/", "categories": "Tech, Server", "tags": "", "date": "2017-03-22 18:02:09 +0800", "snippet": "Mac OS下安装及配置nginx安装包 下载 Nginx 源码包 下载页: http://nginx.org/en/download.html 当前稳定版本: http://nginx.org/download/nginx-1.8.1.tar.gz zlib 下载页: http://zlib.net/ 当前稳定版本: http://zlib.net/zlib-1.2.8.tar.gz 注: Nginx 参考文档中提到需要 1.1.3 以上版本的 zlib pcre 下载页: http://www.pcre.org/ 当前稳定版本: ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz 注: Nginx 参考文档中提到需要 4.4 以上版本的 pcre 配置及安装 First, 进入到包所在的文件夹内 tar zxvf zlib-1.2.8.tar.gz # 得到 zlib-1.2.8 目录tar zxvf pcre-8.36.tar.gz # 得到 pcre-8.36 目录 编译安装 Nginx 这里会将各依赖的源码编译进 Nginx, 所以 –with-zlib 和 –with-pcre 后为对应的依赖源码目录路径。此外, 编译选项中还开启了 HTTPS 的协议支持–with-http_ssl_module, 若不需要 HTTPS, 可取消该选项。 tar zxvf nginx-1.8.0.tar.gz cd nginx-1.8.0 ./configure --prefix=/usr/local/nginx --with-zlib=../zlib-1.2.8 --with-pcre=../pcre-8.36 make sudo make install 其他安装指令（可做了解） nginx大部分常用模块，编译时./configure --help以--without开头的都默认安装。 --prefix=PATH ： 指定nginx的安装目录。默认 /usr/local/nginx --conf-path=PATH ： 设置nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的-c选项。默认为prefix/conf/nginx.conf --user=name： 设置nginx工作进程的用户。安装完成后，可以随时在nginx.conf配置文件更改user指令。默认的用户名是nobody。--group=name类似 --with-pcre ： 设置PCRE库的源码路径，如果已通过yum方式安装，使用--with-pcre自动找到库文件。使用--with-pcre=PATH时，需要从PCRE网站下载pcre库的源码（版本4.4 - 8.30）并解压，剩下的就交给Nginx的./configure和make来完成。perl正则表达式使用在location指令和 ngx_http_rewrite_module模块中。 --with-zlib=PATH ： 指定 zlib（版本1.1.3 - 1.2.5）的源码解压目录。在默认就启用的网络传输压缩模块ngx_http_gzip_module时需要使用zlib 。 --with-http_ssl_module ： 使用https协议模块。默认情况下，该模块没有被构建。前提是openssl与openssl-devel已安装 --with-http_stub_status_module ： 用来监控 Nginx 的当前状态 --with-http_realip_module ： 通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如X-Real-IP 或 X-Forwarded-For)，意义在于能够使得后台服务器记录原始客户端的IP地址 --add-module=PATH ： 添加第三方外部模块，如nginx-sticky-module-ng或缓存模块。每次添加新的模块都要重新编译（Tengine可以在新加入module时无需重新编译） 比如： ./configure \\ &amp;gt; --prefix=/usr \\ &amp;gt; --sbin-path=/usr/sbin/nginx \\ &amp;gt; --conf-path=/etc/nginx/nginx.conf \\ &amp;gt; --error-log-path=/var/log/nginx/error.log \\ &amp;gt; --http-log-path=/var/log/nginx/access.log \\ &amp;gt; --pid-path=/var/run/nginx/nginx.pid \\ &amp;gt; --lock-path=/var/lock/nginx.lock \\ &amp;gt; --user=nginx \\ &amp;gt; --group=nginx \\ &amp;gt; --with-http_ssl_module \\ &amp;gt; --with-http_stub_status_module \\ &amp;gt; --with-http_gzip_static_module \\ &amp;gt; --http-client-body-temp-path=/var/tmp/nginx/client/ \\ &amp;gt; --http-proxy-temp-path=/var/tmp/nginx/proxy/ \\ &amp;gt; --http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \\ &amp;gt; --http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \\ &amp;gt; --with-pcre=../pcre-7.8 &amp;gt; --with-zlib=../zlib-1.2.3 设置监听进入配置文件/usr/local/nginx/conf/nginx.conf ，修改listen下参数：server { listen 85; #监听端口 server_name localhost; #监听服务器 #charset koi8-r; #access_log logs/host.access.log main; location / { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } }启动nginxcd /usr/local/nginx#启动sudo sbin/nginx #浏览器访问 127.0.0.1 测试是否成功启动#重启sudo sbin/nginx -s reload#停止sudo sbin/nginx -s stop修改返回值以bandwidth请求：http://127.0.0.1:8001/v2/bandwidth按照请求的格式创建目录为：/usr/local/nginx/html/v2/ （/usr/local/nginx/html/为默认目录,/v2/为根据请求格式新建的目录）新建bandwidth文件，则文件路径为/usr/local/nginx/html/v2/bandwidth，写入返回值，则构造指定返回报文成功，可按照自己需求进行编辑；然后在浏览器中请求这个接口，返回自定义的内容则配置成功。" }, { "title": "Welcome to Jekyll!", "url": "/posts/welcome-to-jekyll/", "categories": "Blogging, Tutorial", "tags": "", "date": "2017-03-22 17:02:09 +0800", "snippet": "You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.To add new posts, simply add a file in the _posts directory that follows the convention YYYY-MM-DD-name-of-post.ext and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.Jekyll also offers powerful support for code snippets:def print_hi(name) puts &quot;Hi, #{name}&quot;endprint_hi(&#39;Tom&#39;)#=&amp;gt; prints &#39;Hi, Tom&#39; to STDOUT.Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk." } ]
